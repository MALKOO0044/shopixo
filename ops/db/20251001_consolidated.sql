-- Consolidated migrations for quick execution in Supabase SQL Editor
-- Includes base shop schema and CJ integration additions
-- Idempotent: uses IF NOT EXISTS and safe create/replace

-- =====================================
-- 0000_schema-products.sql (base)
-- =====================================
create table if not exists public.products (
  id bigint generated by default as identity primary key,
  title text not null,
  slug text not null unique,
  description text,
  price numeric(10,2) not null,
  images text[] not null default '{}',
  category text not null default 'General',
  rating numeric(3,2) not null default 0,
  stock integer not null default 0 check (stock >= 0),
  variants jsonb not null default '[]'::jsonb,
  created_at timestamptz not null default now()
);

alter table public.products enable row level security;
drop policy if exists "Public can read products" on public.products;
create policy "Public can read products" on public.products
  for select using (true);
drop policy if exists "Service role can manage products" on public.products;
create policy "Service role can manage products" on public.products
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

-- =====================================
-- 0001_schema-cart.sql (base)
-- =====================================
create extension if not exists pgcrypto;

create table if not exists public.cart_sessions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete set null,
  created_at timestamptz not null default now()
);

alter table public.cart_sessions enable row level security;
drop policy if exists "Service role can manage cart sessions" on public.cart_sessions;
create policy "Service role can manage cart sessions" on public.cart_sessions
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

create table if not exists public.cart_items (
  id bigint generated by default as identity primary key,
  session_id uuid not null references public.cart_sessions(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete restrict,
  quantity integer not null check (quantity > 0),
  created_at timestamptz not null default now()
);

create index if not exists idx_cart_items_session_id on public.cart_items(session_id);
create index if not exists idx_cart_items_product_id on public.cart_items(product_id);

alter table public.cart_items enable row level security;
drop policy if exists "Service role can manage cart items" on public.cart_items;
create policy "Service role can manage cart items" on public.cart_items
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

-- =====================================
-- 0002_rpc-decrement_stock.sql (base)
-- =====================================
create or replace function public.decrement_stock(product_id_in bigint, quantity_in integer)
returns void
language plpgsql
security definer
as $$
begin
  update public.products
    set stock = greatest(0, stock - quantity_in)
  where id = product_id_in;
end;
$$;

-- =====================================
-- schema-orders (base)
-- =====================================
create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id),
  total_amount numeric(10, 2) not null,
  status text default 'pending' not null,
  created_at timestamptz default now() not null,
  stripe_session_id text unique
);

create table if not exists public.order_items (
  id bigint generated by default as identity primary key,
  order_id bigint references public.orders(id) on delete cascade not null,
  product_id bigint references public.products(id) not null,
  quantity int not null,
  price numeric(10, 2) not null
);

-- =====================================
-- 0003_orders-policies.sql (base)
-- =====================================
alter table public.orders enable row level security;
drop policy if exists "Service role can manage orders" on public.orders;
create policy "Service role can manage orders" on public.orders
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

alter table public.order_items enable row level security;
drop policy if exists "Service role can manage order items" on public.order_items;
create policy "Service role can manage order items" on public.order_items
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

-- =====================================
-- 0004_rpc-decrement_stock-hardened.sql (base)
-- =====================================
create or replace function public.decrement_stock(product_id_in bigint, quantity_in integer)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if quantity_in is null or quantity_in <= 0 then
    return;
  end if;

  update public.products
    set stock = greatest(0, stock - quantity_in)
  where id = product_id_in;
end;
$$;

-- =====================================
-- CJ Integration Additions
-- =====================================

-- 1) integration_tokens + RLS (service-role only)
create table if not exists public.integration_tokens (
  provider text primary key,
  access_token text,
  access_expiry timestamptz,
  refresh_token text,
  refresh_expiry timestamptz,
  last_auth_call_at timestamptz,
  updated_at timestamptz default now()
);
alter table if exists public.integration_tokens enable row level security;
drop policy if exists "Service role can manage integration_tokens" on public.integration_tokens;
create policy "Service role can manage integration_tokens" on public.integration_tokens
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

-- 2) products: ensure optional CJ columns exist (idempotent)
alter table if exists public.products
  add column if not exists is_active boolean default true,
  add column if not exists video_url text,
  add column if not exists processing_time_hours integer,
  add column if not exists delivery_time_hours integer,
  add column if not exists origin_area text,
  add column if not exists origin_country_code text,
  add column if not exists free_shipping boolean,
  add column if not exists inventory_shipping_fee numeric,
  add column if not exists last_mile_fee numeric,
  add column if not exists cj_product_id text,
  add column if not exists shipping_from text,
  add column if not exists description text,
  add column if not exists category text default 'General'::text;

-- images column as text[] when missing (safety guard if base migration differed)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='products' AND column_name='images'
  ) THEN
    ALTER TABLE public.products ADD COLUMN images text[] NOT NULL DEFAULT '{}'::text[];
  END IF;
END $$;

-- helpful indexes
create index if not exists products_category_idx on public.products(category);
create index if not exists products_cj_product_id_idx on public.products(cj_product_id);

-- 3) normalized product variants table + RLS
create table if not exists public.product_variants (
  id bigserial primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  option_name text not null,
  option_value text not null,
  cj_sku text,
  cj_variant_id text,
  price numeric,
  stock integer not null default 0
);
create unique index if not exists product_variants_unique_opt on public.product_variants(product_id, option_name, option_value);
create index if not exists product_variants_cj_sku_idx on public.product_variants(cj_sku);
create index if not exists product_variants_product_id_idx on public.product_variants(product_id);

alter table if exists public.product_variants enable row level security;
drop policy if exists "Service role can manage product_variants" on public.product_variants;
create policy "Service role can manage product_variants" on public.product_variants
  for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

-- 4) recompute_product_stock from variants (used by API)
create or replace function public.recompute_product_stock(product_id_in bigint)
returns void language plpgsql as $$
begin
  update public.products p
  set stock = coalesce(v.sum_stock, 0)
  from (
    select product_id, sum(stock)::int as sum_stock
    from public.product_variants
    where product_id = product_id_in
    group by product_id
  ) v
  where p.id = product_id_in;
end; $$;

-- 5) CJ-related columns and indexes on orders (tracking)
alter table if exists public.orders
  add column if not exists cj_order_no text,
  add column if not exists shipping_status text,
  add column if not exists tracking_number text,
  add column if not exists carrier text;

create index if not exists orders_cj_order_no_idx on public.orders(cj_order_no);
create index if not exists orders_user_id_idx on public.orders(user_id);
create index if not exists orders_shipping_status_idx on public.orders(shipping_status);
